'''
This file contains functions to post-process the chats generated by chat_vicuna_blip2.py
The main post-processing involves removing questions that have a "no" answer and removing questions that ends with a . instead of a ?, which likely suggests problems in the generation of the question.
'''
import os 
import pickle
import json

def read_chats(path:str):
    '''
    This function takes a path to a folder containing a different pkl file for each chat.
    Each file contains a list of questions and answers.
    Each conversation is put in a dictionary with the key being the name of the file.
    '''
    files = os.listdir(path)
    chats = {}
    for file in files:
        with open(os.path.join(path, file), "rb") as f:
            chats[file] = pickle.load(f)[:-1]
    return chats

def remove_no_answers(dict_in:dict):
    '''
    This function removes the questions that have a "no" answer.
    '''
    dict_out = {}
    discarded = 0 
    all = 0 
    for key in dict_in.keys():
        for i in range(int(len(dict_in[key])/2)):
            question = dict_in[key][i*2]
            answer = dict_in[key][i*2+1]
            all+=1
            if(answer[1] != "no"):
                if key not in dict_out.keys():
                    dict_out[key] = []
                dict_out[key].append(question)
                dict_out[key].append(answer)
            else:
                discarded+=1
    
    print("All questions: ", all)
    print("Discarded questions: ", discarded)
    
    return dict_out

def remove_answers_ending_with_point(dict_in:dict):
    '''
    This function removes the questions that end with a point.
    '''
    dict_out = {}
    discarded = 0 
    all = 0 
    for key in dict_in.keys():
        for i in range(int(len(dict_in[key])/2)):
            question = dict_in[key][i*2]
            answer = dict_in[key][i*2+1]
            all+=1
            if(question[1][-2] != "."):
                if key not in dict_out.keys():
                    dict_out[key] = []
                dict_out[key].append(question)
                dict_out[key].append(answer)
            else:
                discarded+=1
    
    print("All questions: ", all)
    print("Discarded questions: ", discarded)
    
    return dict_out

def discard_dont_know(dict_in:dict):
    '''
    This function removes the questions that have a "don't know" answer.
    '''
    dict_out = {}
    discarded = 0 
    all = 0 
    for key in dict_in.keys():
        for i in range(int(len(dict_in[key])/2)):
            question = dict_in[key][i*2]
            answer = dict_in[key][i*2+1]
            all+=1
            if(answer[1] != "don't know" and answer[1] != "not sure"):
                if key not in dict_out.keys():
                    dict_out[key] = []
                dict_out[key].append(question)
                dict_out[key].append(answer)
            else:
                discarded+=1
    
    print("All questions: ", all)
    print("Discarded questions: ", discarded)
    
    return dict_out

def save_dict(dict_in:dict, path:str):
    '''
    This function saves the dictionary in a path using json formatting.
    '''
    with open(path, "w") as f:
        json.dump(dict_in, f, indent=4)


if __name__=="__main__":
    path = "chats_cache"
    out = read_chats(path)
    print("Total number of images: ", len(out))
    dict_out = remove_no_answers(out)
    dict_out = remove_answers_ending_with_point(dict_out)
    dict_out = discard_dont_know(dict_out)
    path = "out.json"
    save_dict(dict_out, path)
    
    